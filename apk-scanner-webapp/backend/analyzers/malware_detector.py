import logging
import hashlib
import re
from collections import defaultdict

logger = logging.getLogger(__name__)

class MalwareDetector:
    def __init__(self):
        # Malware signature patterns
        self.malware_signatures = {
            'file_patterns': [
                'payload', 'exploit', 'shell', 'root', 'su', 'busybox',
                'dropper', 'loader', 'backdoor', 'keylog', 'sms_steal',
                'trojan', 'spyware', 'adware', 'ransomware', 'botnet'
            ],

            'suspicious_apis': [
                b'Runtime.exec', b'ProcessBuilder', b'getDeviceId', b'getSubscriberId',
                b'sendTextMessage', b'abortBroadcast', b'setWifiEnabled',
                b'getInstalledPackages', b'getRunningTasks', b'killBackgroundProcesses',
                b'loadClass', b'getMethod', b'getDeclaredMethod', b'invoke'
            ],

            'crypto_apis': [
                b'Cipher', b'MessageDigest', b'SecretKey', b'KeyGenerator',
                b'encrypt', b'decrypt', b'AES', b'DES', b'RSA'
            ],

            'network_apis': [
                b'HttpURLConnection', b'Socket', b'ServerSocket', b'DatagramSocket',
                b'URL', b'URLConnection', b'HttpClient', b'OkHttp'
            ],

            'privilege_escalation': [
                b'su -c', b'/system/bin/su', b'/system/xbin/su',
                b'chmod 777', b'mount -o remount', b'busybox'
            ]
        }

        # Known malware family indicators
        self.malware_families = {
            'Android.Trojan.Banker': [
                b'overlay', b'banking', b'creditcard', b'keylogger'
            ],
            'Android.Adware': [
                b'advertisement', b'popup', b'banner', b'interstitial'
            ],
            'Android.Spyware': [
                b'location', b'contacts', b'sms', b'call_log', b'microphone'
            ],
            'Android.Ransomware': [
                b'encrypt', b'ransom', b'bitcoin', b'payment', b'unlock'
            ],
            'Android.Backdoor': [
                b'remote', b'command', b'control', b'shell', b'execute'
            ]
        }

    def analyze(self, apk):
        """Comprehensive malware detection analysis"""
        try:
            malware_results = {
                'risk_level': 'LOW',
                'indicators': [],
                'suspicious_files': [],
                'suspicious_apis': [],
                'malware_families': [],
                'behavioral_patterns': [],
                'encryption_usage': [],
                'network_behavior': [],
                'privilege_escalation': [],
                'overall_score': 0
            }

            # Analyze file structure for malware indicators
            self._analyze_file_structure(apk, malware_results)

            # Analyze DEX files for malicious code patterns
            self._analyze_dex_files(apk, malware_results)

            # Check for known malware families
            self._detect_malware_families(apk, malware_results)

            # Analyze behavioral patterns
            self._analyze_behavioral_patterns(apk, malware_results)

            # Calculate overall risk
            self._calculate_malware_risk(malware_results)

            return malware_results

        except Exception as e:
            logger.error(f"Malware detection failed: {str(e)}")
            return self._get_fallback_malware_analysis()

    def _analyze_file_structure(self, apk, results):
        """Analyze APK file structure for malware indicators"""
        try:
            file_list = apk.namelist()

            for filename in file_list:
                # Check for suspicious file patterns
                for pattern in self.malware_signatures['file_patterns']:
                    if pattern.lower() in filename.lower():
                        results['suspicious_files'].append({
                            'file': filename,
                            'reason': f'Contains suspicious pattern: {pattern}',
                            'risk': 'high'
                        })

                # Check for hidden or unusual files
                if filename.startswith('.') and not filename.startswith('./'):
                    results['suspicious_files'].append({
                        'file': filename,
                        'reason': 'Hidden file',
                        'risk': 'medium'
                    })

                # Check for executable files in unusual locations
                if filename.endswith('.so') and not filename.startswith('lib/'):
                    results['suspicious_files'].append({
                        'file': filename,
                        'reason': 'Native library in unusual location',
                        'risk': 'medium'
                    })

                # Check for multiple DEX files (potential packing)
                dex_files = [f for f in file_list if f.endswith('.dex')]
                if len(dex_files) > 3:
                    results['indicators'].append({
                        'type': 'packing',
                        'description': f'Multiple DEX files detected ({len(dex_files)})',
                        'risk': 'medium'
                    })

        except Exception as e:
            logger.warning(f"File structure analysis failed: {str(e)}")

    def _analyze_dex_files(self, apk, results):
        """Analyze DEX files for malicious code patterns"""
        try:
            dex_files = [f for f in apk.namelist() if f.endswith('.dex')]

            for dex_file in dex_files[:3]:  # Limit analysis to first 3 DEX files
                try:
                    dex_data = apk.read(dex_file)

                    # Check for suspicious APIs
                    self._check_suspicious_apis(dex_data, results)

                    # Check for crypto usage
                    self._check_crypto_usage(dex_data, results)

                    # Check for network behavior
                    self._check_network_behavior(dex_data, results)

                    # Check for privilege escalation
                    self._check_privilege_escalation(dex_data, results)

                except Exception as e:
                    logger.warning(f"DEX file analysis failed for {dex_file}: {str(e)}")

        except Exception as e:
            logger.warning(f"DEX analysis failed: {str(e)}")

    def _check_suspicious_apis(self, dex_data, results):
        """Check for suspicious API usage in DEX data"""
        for api in self.malware_signatures['suspicious_apis']:
            if api in dex_data:
                results['suspicious_apis'].append({
                    'api': api.decode('utf-8', errors='ignore'),
                    'risk': self._assess_api_risk(api),
                    'description': self._get_api_description(api)
                })

    def _check_crypto_usage(self, dex_data, results):
        """Check for cryptographic API usage"""
        for crypto_api in self.malware_signatures['crypto_apis']:
            if crypto_api in dex_data:
                results['encryption_usage'].append({
                    'api': crypto_api.decode('utf-8', errors='ignore'),
                    'description': 'Cryptographic operations detected'
                })

    def _check_network_behavior(self, dex_data, results):
        """Check for network-related behavior"""
        for network_api in self.malware_signatures['network_apis']:
            if network_api in dex_data:
                results['network_behavior'].append({
                    'api': network_api.decode('utf-8', errors='ignore'),
                    'description': 'Network communication capability'
                })

    def _check_privilege_escalation(self, dex_data, results):
        """Check for privilege escalation attempts"""
        for priv_pattern in self.malware_signatures['privilege_escalation']:
            if priv_pattern in dex_data:
                results['privilege_escalation'].append({
                    'pattern': priv_pattern.decode('utf-8', errors='ignore'),
                    'risk': 'high',
                    'description': 'Potential privilege escalation attempt'
                })

    def _detect_malware_families(self, apk, results):
        """Detect known malware family patterns"""
        try:
            dex_files = [f for f in apk.namelist() if f.endswith('.dex')]

            for dex_file in dex_files[:2]:
                try:
                    dex_data = apk.read(dex_file)

                    for family_name, patterns in self.malware_families.items():
                        match_count = 0
                        for pattern in patterns:
                            if pattern in dex_data:
                                match_count += 1

                        # If multiple patterns match, likely this malware family
                        if match_count >= 2:
                            results['malware_families'].append({
                                'family': family_name,
                                'confidence': min(match_count / len(patterns) * 100, 95),
                                'matches': match_count
                            })

                except Exception as e:
                    logger.warning(f"Malware family detection failed for {dex_file}: {str(e)}")

        except Exception as e:
            logger.warning(f"Malware family detection failed: {str(e)}")

    def _analyze_behavioral_patterns(self, apk, results):
        """Analyze behavioral patterns that indicate malware"""
        try:
            # Check for suspicious file combinations
            file_list = apk.namelist()

            # Pattern: Hidden files + network capability
            has_hidden_files = any(f.startswith('.') for f in file_list)
            has_network = any('network' in api.get('api', '') for api in results['network_behavior'])

            if has_hidden_files and has_network:
                results['behavioral_patterns'].append({
                    'pattern': 'Hidden files with network access',
                    'risk': 'high',
                    'description': 'Combination suggests covert communication'
                })

            # Pattern: Multiple DEX + crypto + network
            dex_count = len([f for f in file_list if f.endswith('.dex')])
            has_crypto = len(results['encryption_usage']) > 0

            if dex_count > 2 and has_crypto and has_network:
                results['behavioral_patterns'].append({
                    'pattern': 'Complex structure with encryption and network',
                    'risk': 'high',
                    'description': 'Sophisticated malware characteristics'
                })

            # Pattern: Privilege escalation + system modification
            has_priv_esc = len(results['privilege_escalation']) > 0
            has_sys_apis = any('system' in api.get('api', '').lower()
                              for api in results['suspicious_apis'])

            if has_priv_esc and has_sys_apis:
                results['behavioral_patterns'].append({
                    'pattern': 'Privilege escalation with system modification',
                    'risk': 'critical',
                    'description': 'Potentially destructive malware behavior'
                })

        except Exception as e:
            logger.warning(f"Behavioral pattern analysis failed: {str(e)}")

    def _calculate_malware_risk(self, results):
        """Calculate overall malware risk score and level"""
        score = 0

        # Scoring weights
        weights = {
            'suspicious_files': 15,
            'suspicious_apis': 10,
            'malware_families': 40,
            'behavioral_patterns': 25,
            'privilege_escalation': 30,
            'encryption_usage': 5
        }

        # Calculate score based on findings
        score += len(results['suspicious_files']) * weights['suspicious_files']
        score += len(results['suspicious_apis']) * weights['suspicious_apis']
        score += len(results['malware_families']) * weights['malware_families']
        score += len(results['privilege_escalation']) * weights['privilege_escalation']
        score += len(results['encryption_usage']) * weights['encryption_usage']

        # Behavioral patterns have variable weights
        for pattern in results['behavioral_patterns']:
            if pattern['risk'] == 'critical':
                score += weights['behavioral_patterns'] * 1.5
            elif pattern['risk'] == 'high':
                score += weights['behavioral_patterns']
            else:
                score += weights['behavioral_patterns'] * 0.5

        results['overall_score'] = min(score, 100)

        # Determine risk level
        if score >= 80:
            results['risk_level'] = 'CRITICAL'
        elif score >= 60:
            results['risk_level'] = 'HIGH'
        elif score >= 30:
            results['risk_level'] = 'MEDIUM'
        else:
            results['risk_level'] = 'LOW'

        # Add overall indicators
        total_indicators = (len(results['suspicious_files']) +
                          len(results['suspicious_apis']) +
                          len(results['malware_families']) +
                          len(results['behavioral_patterns']))

        results['indicators'].append({
            'type': 'summary',
            'description': f'Total suspicious indicators found: {total_indicators}',
            'risk': results['risk_level'].lower()
        })

    def _assess_api_risk(self, api):
        """Assess risk level of specific API"""
        high_risk_apis = [b'Runtime.exec', b'getDeviceId', b'sendTextMessage',
                         b'killBackgroundProcesses']
        if api in high_risk_apis:
            return 'high'
        return 'medium'

    def _get_api_description(self, api):
        """Get description for API usage"""
        api_descriptions = {
            b'Runtime.exec': 'Execute system commands',
            b'getDeviceId': 'Access device identifier',
            b'sendTextMessage': 'Send SMS messages',
            b'getInstalledPackages': 'List installed applications',
            b'killBackgroundProcesses': 'Terminate other applications'
        }
        return api_descriptions.get(api, 'Suspicious API usage detected')

    def _get_fallback_malware_analysis(self):
        """Provide fallback malware analysis when detection fails"""
        return {
            'risk_level': 'UNKNOWN',
            'indicators': [{'type': 'error', 'description': 'Malware analysis failed', 'risk': 'medium'}],
            'suspicious_files': [],
            'suspicious_apis': [],
            'malware_families': [],
            'behavioral_patterns': [],
            'encryption_usage': [],
            'network_behavior': [],
            'privilege_escalation': [],
            'overall_score': 50,
            'error': 'Malware detection analysis incomplete'
        }
